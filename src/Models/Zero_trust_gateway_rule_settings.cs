// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace Soenneker.Cloudflare.OpenApiClient.Models
{
    /// <summary>
    /// Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether the API modifies the value. Use API-returned values in your configuration to prevent drift.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class Zero_trust_gateway_rule_settings : IAdditionalDataHolder, IParsable
    {
        /// <summary>Add custom headers to allowed requests as key-value pairs. Use header names as keys that map to arrays of header values. Settable only for `http` rules with the action set to `allow`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_add_headers? AddHeaders { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_add_headers AddHeaders { get; set; }
#endif
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>Set to enable MSP children to bypass this rule. Only parent MSP accounts can set this. this rule. Settable for all types of rules.</summary>
        public bool? AllowChildBypass { get; set; }
        /// <summary>Define the settings for the Audit SSH action. Settable only for `l4` rules with `audit_ssh` action.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_audit_ssh? AuditSsh { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_audit_ssh AuditSsh { get; set; }
#endif
        /// <summary>Configure browser isolation behavior. Settable only for `http` rules with the action set to `isolate`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_biso_admin_controls? BisoAdminControls { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_biso_admin_controls BisoAdminControls { get; set; }
#endif
        /// <summary>Configure custom block page settings. If missing or null, use the account settings. Settable only for `http` rules with the action set to `block`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_block_page? BlockPage { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_block_page BlockPage { get; set; }
#endif
        /// <summary>Enable the custom block page. Settable only for `dns` rules with action `block`.</summary>
        public bool? BlockPageEnabled { get; set; }
        /// <summary>Explain why the rule blocks the request. The custom block page shows this text (if enabled). Settable only for `dns`, `l4`, and `http` rules when the action set to `block`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? BlockReason { get; set; }
#nullable restore
#else
        public string BlockReason { get; set; }
#endif
        /// <summary>Set to enable MSP accounts to bypass their parent&apos;s rules. Only MSP child accounts can set this. Settable for all types of rules.</summary>
        public bool? BypassParentRule { get; set; }
        /// <summary>Configure session check behavior. Settable only for `l4` and `http` rules with the action set to `allow`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_check_session? CheckSession { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_check_session CheckSession { get; set; }
#endif
        /// <summary>Configure custom resolvers to route queries that match the resolver policy. Unused with &apos;resolve_dns_through_cloudflare&apos; or &apos;resolve_dns_internally&apos; settings. DNS queries get routed to the address closest to their origin. Only valid when a rule&apos;s action set to &apos;resolve&apos;. Settable only for `dns_resolver` rules.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_dns_resolvers? DnsResolvers { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_dns_resolvers DnsResolvers { get; set; }
#endif
        /// <summary>Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs. Settable only for `egress` rules.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_egress? Egress { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_egress Egress { get; set; }
#endif
        /// <summary>Ignore category matches at CNAME domains in a response. When off, evaluate categories in this rule against all CNAME domain categories in the response. Settable only for `dns` and `dns_resolver` rules.</summary>
        public bool? IgnoreCnameCategoryMatches { get; set; }
        /// <summary>Specify whether to disable DNSSEC validation (for Allow actions) [INSECURE]. Settable only for `dns` rules.</summary>
        public bool? InsecureDisableDnssecValidation { get; set; }
        /// <summary>Enable IPs in DNS resolver category blocks. The system blocks only domain name categories unless you enable this setting. Settable only for `dns` and `dns_resolver` rules.</summary>
        public bool? IpCategories { get; set; }
        /// <summary>Indicates whether to include IPs in DNS resolver indicator feed blocks. Default, indicator feeds block only domain names. Settable only for `dns` and `dns_resolver` rules.</summary>
        public bool? IpIndicatorFeeds { get; set; }
        /// <summary>Send matching traffic to the supplied destination IP address and port. Settable only for `l4` rules with the action set to `l4_override`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_l4override? L4override { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_l4override L4override { get; set; }
#endif
        /// <summary>Configure a notification to display on the user&apos;s device when this rule matched. Settable for all types of rules with the action set to `block`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_notification_settings? NotificationSettings { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_notification_settings NotificationSettings { get; set; }
#endif
        /// <summary>Defines a hostname for override, for the matching DNS queries. Settable only for `dns` rules with the action set to `override`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? OverrideHost { get; set; }
#nullable restore
#else
        public string OverrideHost { get; set; }
#endif
        /// <summary>Defines a an IP or set of IPs for overriding matched DNS queries. Settable only for `dns` rules with the action set to `override`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<string>? OverrideIps { get; set; }
#nullable restore
#else
        public List<string> OverrideIps { get; set; }
#endif
        /// <summary>Configure DLP payload logging. Settable only for `http` rules.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_payload_log? PayloadLog { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_payload_log PayloadLog { get; set; }
#endif
        /// <summary>Configure settings that apply to quarantine rules. Settable only for `http` rules.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_quarantine? Quarantine { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_quarantine Quarantine { get; set; }
#endif
        /// <summary>Apply settings to redirect rules. Settable only for `http` rules with the action set to `redirect`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_redirect? Redirect { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_redirect Redirect { get; set; }
#endif
        /// <summary>Configure to forward the query to the internal DNS service, passing the specified &apos;view_id&apos; as input. Not used when &apos;dns_resolvers&apos; is specified or &apos;resolve_dns_through_cloudflare&apos; is set. Only valid when a rule&apos;s action set to &apos;resolve&apos;. Settable only for `dns_resolver` rules.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_resolve_dns_internally? ResolveDnsInternally { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_resolve_dns_internally ResolveDnsInternally { get; set; }
#endif
        /// <summary>Enable to send queries that match the policy to Cloudflare&apos;s default 1.1.1.1 DNS resolver. Cannot set when &apos;dns_resolvers&apos; specified or &apos;resolve_dns_internally&apos; is set. Only valid when a rule&apos;s action set to &apos;resolve&apos;. Settable only for `dns_resolver` rules.</summary>
        public bool? ResolveDnsThroughCloudflare { get; set; }
        /// <summary>Configure behavior when an upstream certificate is invalid or an SSL error occurs. Settable only for `http` rules with the action set to `allow`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_untrusted_cert? UntrustedCert { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_untrusted_cert UntrustedCert { get; set; }
#endif
        /// <summary>
        /// Instantiates a new <see cref="global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings"/> and sets the default values.
        /// </summary>
        public Zero_trust_gateway_rule_settings()
        {
            AdditionalData = new Dictionary<string, object>();
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "add_headers", n => { AddHeaders = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_add_headers>(global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_add_headers.CreateFromDiscriminatorValue); } },
                { "allow_child_bypass", n => { AllowChildBypass = n.GetBoolValue(); } },
                { "audit_ssh", n => { AuditSsh = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_audit_ssh>(global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_audit_ssh.CreateFromDiscriminatorValue); } },
                { "biso_admin_controls", n => { BisoAdminControls = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_biso_admin_controls>(global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_biso_admin_controls.CreateFromDiscriminatorValue); } },
                { "block_page", n => { BlockPage = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_block_page>(global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_block_page.CreateFromDiscriminatorValue); } },
                { "block_page_enabled", n => { BlockPageEnabled = n.GetBoolValue(); } },
                { "block_reason", n => { BlockReason = n.GetStringValue(); } },
                { "bypass_parent_rule", n => { BypassParentRule = n.GetBoolValue(); } },
                { "check_session", n => { CheckSession = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_check_session>(global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_check_session.CreateFromDiscriminatorValue); } },
                { "dns_resolvers", n => { DnsResolvers = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_dns_resolvers>(global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_dns_resolvers.CreateFromDiscriminatorValue); } },
                { "egress", n => { Egress = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_egress>(global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_egress.CreateFromDiscriminatorValue); } },
                { "ignore_cname_category_matches", n => { IgnoreCnameCategoryMatches = n.GetBoolValue(); } },
                { "insecure_disable_dnssec_validation", n => { InsecureDisableDnssecValidation = n.GetBoolValue(); } },
                { "ip_categories", n => { IpCategories = n.GetBoolValue(); } },
                { "ip_indicator_feeds", n => { IpIndicatorFeeds = n.GetBoolValue(); } },
                { "l4override", n => { L4override = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_l4override>(global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_l4override.CreateFromDiscriminatorValue); } },
                { "notification_settings", n => { NotificationSettings = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_notification_settings>(global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_notification_settings.CreateFromDiscriminatorValue); } },
                { "override_host", n => { OverrideHost = n.GetStringValue(); } },
                { "override_ips", n => { OverrideIps = n.GetCollectionOfPrimitiveValues<string>()?.AsList(); } },
                { "payload_log", n => { PayloadLog = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_payload_log>(global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_payload_log.CreateFromDiscriminatorValue); } },
                { "quarantine", n => { Quarantine = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_quarantine>(global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_quarantine.CreateFromDiscriminatorValue); } },
                { "redirect", n => { Redirect = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_redirect>(global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_redirect.CreateFromDiscriminatorValue); } },
                { "resolve_dns_internally", n => { ResolveDnsInternally = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_resolve_dns_internally>(global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_resolve_dns_internally.CreateFromDiscriminatorValue); } },
                { "resolve_dns_through_cloudflare", n => { ResolveDnsThroughCloudflare = n.GetBoolValue(); } },
                { "untrusted_cert", n => { UntrustedCert = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_untrusted_cert>(global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_untrusted_cert.CreateFromDiscriminatorValue); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_add_headers>("add_headers", AddHeaders);
            writer.WriteBoolValue("allow_child_bypass", AllowChildBypass);
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_audit_ssh>("audit_ssh", AuditSsh);
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_biso_admin_controls>("biso_admin_controls", BisoAdminControls);
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_block_page>("block_page", BlockPage);
            writer.WriteBoolValue("block_page_enabled", BlockPageEnabled);
            writer.WriteStringValue("block_reason", BlockReason);
            writer.WriteBoolValue("bypass_parent_rule", BypassParentRule);
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_check_session>("check_session", CheckSession);
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_dns_resolvers>("dns_resolvers", DnsResolvers);
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_egress>("egress", Egress);
            writer.WriteBoolValue("ignore_cname_category_matches", IgnoreCnameCategoryMatches);
            writer.WriteBoolValue("insecure_disable_dnssec_validation", InsecureDisableDnssecValidation);
            writer.WriteBoolValue("ip_categories", IpCategories);
            writer.WriteBoolValue("ip_indicator_feeds", IpIndicatorFeeds);
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_l4override>("l4override", L4override);
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_notification_settings>("notification_settings", NotificationSettings);
            writer.WriteStringValue("override_host", OverrideHost);
            writer.WriteCollectionOfPrimitiveValues<string>("override_ips", OverrideIps);
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_payload_log>("payload_log", PayloadLog);
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_quarantine>("quarantine", Quarantine);
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_redirect>("redirect", Redirect);
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_resolve_dns_internally>("resolve_dns_internally", ResolveDnsInternally);
            writer.WriteBoolValue("resolve_dns_through_cloudflare", ResolveDnsThroughCloudflare);
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Zero_trust_gateway_rule_settings_untrusted_cert>("untrusted_cert", UntrustedCert);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
#pragma warning restore CS0618
