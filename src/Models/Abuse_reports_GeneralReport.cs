// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace Soenneker.Cloudflare.OpenApiClient.Models
{
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    #pragma warning disable CS1591
    public partial class Abuse_reports_GeneralReport : global::Soenneker.Cloudflare.OpenApiClient.Models.Abuse_reports_BaseReportFields, IParsable
    #pragma warning restore CS1591
    {
        /// <summary>A list of IP addresses separated by ‘\n’ (new line character). The list of destination IPs should not exceed 30 IP addresses. Each one of the IP addresses ought to be unique.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? DestinationIps { get; set; }
#nullable restore
#else
        public string DestinationIps { get; set; }
#endif
        /// <summary>Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.</summary>
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Abuse_reports_GeneralReport_host_notification? HostNotification { get; set; }
        /// <summary>A detailed description of the infringement, including any necessary access details and the exact steps needed to view the content, not exceeding 5000 characters.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Justification { get; set; }
#nullable restore
#else
        public string Justification { get; set; }
#endif
        /// <summary>Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.</summary>
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Abuse_reports_GeneralReport_owner_notification? OwnerNotification { get; set; }
        /// <summary>A comma separated list of ports and protocols e.g. 80/TCP, 22/UDP. The total size of the field should not exceed 2000 characters. Each individual port/protocol should not exceed 100 characters. The list should not have more than 30 unique ports and protocols.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? PortsProtocols { get; set; }
#nullable restore
#else
        public string PortsProtocols { get; set; }
#endif
        /// <summary>A list of IP addresses separated by ‘\n’ (new line character). The list of source IPs should not exceed 30 IP addresses. Each one of the IP addresses ought to be unique.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? SourceIps { get; set; }
#nullable restore
#else
        public string SourceIps { get; set; }
#endif
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Soenneker.Cloudflare.OpenApiClient.Models.Abuse_reports_GeneralReport"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static new global::Soenneker.Cloudflare.OpenApiClient.Models.Abuse_reports_GeneralReport CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::Soenneker.Cloudflare.OpenApiClient.Models.Abuse_reports_GeneralReport();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public override IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>(base.GetFieldDeserializers())
            {
                { "destination_ips", n => { DestinationIps = n.GetStringValue(); } },
                { "host_notification", n => { HostNotification = n.GetEnumValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Abuse_reports_GeneralReport_host_notification>(); } },
                { "justification", n => { Justification = n.GetStringValue(); } },
                { "owner_notification", n => { OwnerNotification = n.GetEnumValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Abuse_reports_GeneralReport_owner_notification>(); } },
                { "ports_protocols", n => { PortsProtocols = n.GetStringValue(); } },
                { "source_ips", n => { SourceIps = n.GetStringValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public override void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            base.Serialize(writer);
            writer.WriteStringValue("destination_ips", DestinationIps);
            writer.WriteEnumValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Abuse_reports_GeneralReport_host_notification>("host_notification", HostNotification);
            writer.WriteStringValue("justification", Justification);
            writer.WriteEnumValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Abuse_reports_GeneralReport_owner_notification>("owner_notification", OwnerNotification);
            writer.WriteStringValue("ports_protocols", PortsProtocols);
            writer.WriteStringValue("source_ips", SourceIps);
        }
    }
}
#pragma warning restore CS0618
