// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace Soenneker.Cloudflare.OpenApiClient.Models
{
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    #pragma warning disable CS1591
    public partial class Load_balancing_monitor_editable : IAdditionalDataHolder, IParsable
    #pragma warning restore CS1591
    {
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.</summary>
        public bool? AllowInsecure { get; set; }
        /// <summary>To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.</summary>
        public int? ConsecutiveDown { get; set; }
        /// <summary>To be marked healthy the monitored origin must pass this healthcheck N consecutive times.</summary>
        public int? ConsecutiveUp { get; set; }
        /// <summary>Object description.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Description { get; set; }
#nullable restore
#else
        public string Description { get; set; }
#endif
        /// <summary>A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ExpectedBody { get; set; }
#nullable restore
#else
        public string ExpectedBody { get; set; }
#endif
        /// <summary>The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ExpectedCodes { get; set; }
#nullable restore
#else
        public string ExpectedCodes { get; set; }
#endif
        /// <summary>Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.</summary>
        public bool? FollowRedirects { get; set; }
        /// <summary>The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Load_balancing_header? Header { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Load_balancing_header Header { get; set; }
#endif
        /// <summary>The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.</summary>
        public int? Interval { get; set; }
        /// <summary>The method to use for the health check. This defaults to &apos;GET&apos; for HTTP/HTTPS based checks and &apos;connection_established&apos; for TCP based health checks.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Method { get; set; }
#nullable restore
#else
        public string Method { get; set; }
#endif
        /// <summary>The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Path { get; set; }
#nullable restore
#else
        public string Path { get; set; }
#endif
        /// <summary>The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).</summary>
        public int? Port { get; set; }
        /// <summary>Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ProbeZone { get; set; }
#nullable restore
#else
        public string ProbeZone { get; set; }
#endif
        /// <summary>The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.</summary>
        public int? Retries { get; set; }
        /// <summary>The timeout (in seconds) before marking the health check as failed.</summary>
        public int? Timeout { get; set; }
        /// <summary>The protocol to use for the health check. Currently supported protocols are &apos;HTTP&apos;,&apos;HTTPS&apos;, &apos;TCP&apos;, &apos;ICMP-PING&apos;, &apos;UDP-ICMP&apos;, and &apos;SMTP&apos;.</summary>
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Load_balancing_type? Type { get; set; }
        /// <summary>
        /// Instantiates a new <see cref="global::Soenneker.Cloudflare.OpenApiClient.Models.Load_balancing_monitor_editable"/> and sets the default values.
        /// </summary>
        public Load_balancing_monitor_editable()
        {
            AdditionalData = new Dictionary<string, object>();
            Type = global::Soenneker.Cloudflare.OpenApiClient.Models.Load_balancing_type.Http;
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Soenneker.Cloudflare.OpenApiClient.Models.Load_balancing_monitor_editable"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::Soenneker.Cloudflare.OpenApiClient.Models.Load_balancing_monitor_editable CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::Soenneker.Cloudflare.OpenApiClient.Models.Load_balancing_monitor_editable();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "allow_insecure", n => { AllowInsecure = n.GetBoolValue(); } },
                { "consecutive_down", n => { ConsecutiveDown = n.GetIntValue(); } },
                { "consecutive_up", n => { ConsecutiveUp = n.GetIntValue(); } },
                { "description", n => { Description = n.GetStringValue(); } },
                { "expected_body", n => { ExpectedBody = n.GetStringValue(); } },
                { "expected_codes", n => { ExpectedCodes = n.GetStringValue(); } },
                { "follow_redirects", n => { FollowRedirects = n.GetBoolValue(); } },
                { "header", n => { Header = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Load_balancing_header>(global::Soenneker.Cloudflare.OpenApiClient.Models.Load_balancing_header.CreateFromDiscriminatorValue); } },
                { "interval", n => { Interval = n.GetIntValue(); } },
                { "method", n => { Method = n.GetStringValue(); } },
                { "path", n => { Path = n.GetStringValue(); } },
                { "port", n => { Port = n.GetIntValue(); } },
                { "probe_zone", n => { ProbeZone = n.GetStringValue(); } },
                { "retries", n => { Retries = n.GetIntValue(); } },
                { "timeout", n => { Timeout = n.GetIntValue(); } },
                { "type", n => { Type = n.GetEnumValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Load_balancing_type>(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            writer.WriteBoolValue("allow_insecure", AllowInsecure);
            writer.WriteIntValue("consecutive_down", ConsecutiveDown);
            writer.WriteIntValue("consecutive_up", ConsecutiveUp);
            writer.WriteStringValue("description", Description);
            writer.WriteStringValue("expected_body", ExpectedBody);
            writer.WriteStringValue("expected_codes", ExpectedCodes);
            writer.WriteBoolValue("follow_redirects", FollowRedirects);
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Load_balancing_header>("header", Header);
            writer.WriteIntValue("interval", Interval);
            writer.WriteStringValue("method", Method);
            writer.WriteStringValue("path", Path);
            writer.WriteIntValue("port", Port);
            writer.WriteStringValue("probe_zone", ProbeZone);
            writer.WriteIntValue("retries", Retries);
            writer.WriteIntValue("timeout", Timeout);
            writer.WriteEnumValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Load_balancing_type>("type", Type);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
#pragma warning restore CS0618
