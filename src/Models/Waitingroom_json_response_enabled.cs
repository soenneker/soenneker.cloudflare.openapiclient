// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace Soenneker.Cloudflare.OpenApiClient.Models
{
    /// <summary>
    /// Only available for the Waiting Room Advanced subscription. If `true`, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object with information on the user&apos;s status in the waiting room as opposed to the configured static HTML page. This JSON response object has one property `cfWaitingRoom` which is an object containing the following fields:1. `inWaitingRoom`: Boolean indicating if the user is in the waiting room (always **true**).2. `waitTimeKnown`: Boolean indicating if the current estimated wait times are accurate. If **false**, they are not available.3. `waitTime`: Valid only when `waitTimeKnown` is **true**. Integer indicating the current estimated time in minutes the user will wait in the waiting room. When `queueingMethod` is **random**, this is set to `waitTime50Percentile`.4. `waitTime25Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 25% of users that gain entry the fastest (25th percentile).5. `waitTime50Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 50% of users that gain entry the fastest (50th percentile). In other words, half of the queued users are expected to let into the origin website before `waitTime50Percentile` and half are expected to be let in after it.6. `waitTime75Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 75% of users that gain entry the fastest (75th percentile).7. `waitTimeFormatted`: String displaying the `waitTime` formatted in English for users. If `waitTimeKnown` is **false**, `waitTimeFormatted` will display **unavailable**.8. `queueIsFull`: Boolean indicating if the waiting room&apos;s queue is currently full and not accepting new users at the moment.9. `queueAll`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website.10. `lastUpdated`: String displaying the timestamp as an ISO 8601 string of the user&apos;s last attempt to leave the waiting room and be let into the origin website. The user is able to make another attempt after `refreshIntervalSeconds` past this time. If the user makes a request too soon, it will be ignored and `lastUpdated` will not change.11. `refreshIntervalSeconds`: Integer indicating the number of seconds after `lastUpdated` until the user is able to make another attempt to leave the waiting room and be let into the origin website. When the `queueingMethod` is `reject`, there is no specified refresh time â€”\_it will always be **zero**.12. `queueingMethod`: The queueing method currently used by the waiting room. It is either **fifo**, **random**, **passthrough**, or **reject**.13. `isFIFOQueue`: Boolean indicating if the waiting room uses a FIFO (First-In-First-Out) queue.14. `isRandomQueue`: Boolean indicating if the waiting room uses a Random queue where users gain access randomly.15. `isPassthroughQueue`: Boolean indicating if the waiting room uses a passthrough queue. Keep in mind that when passthrough is enabled, this JSON response will only exist when `queueAll` is **true** or `isEventPrequeueing` is **true** because in all other cases requests will go directly to the origin.16. `isRejectQueue`: Boolean indicating if the waiting room uses a reject queue.17. `isEventActive`: Boolean indicating if an event is currently occurring. Events are able to change a waiting room&apos;s behavior during a specified period of time. For additional information, look at the event properties `prequeue_start_time`, `event_start_time`, and `event_end_time` in the documentation for creating waiting room events. Events are considered active between these start and end times, as well as during the prequeueing period if it exists.18. `isEventPrequeueing`: Valid only when `isEventActive` is **true**. Boolean indicating if an event is currently prequeueing users before it starts.19. `timeUntilEventStart`: Valid only when `isEventPrequeueing` is **true**. Integer indicating the number of minutes until the event starts.20. `timeUntilEventStartFormatted`: String displaying the `timeUntilEventStart` formatted in English for users. If `isEventPrequeueing` is **false**, `timeUntilEventStartFormatted` will display **unavailable**.21. `timeUntilEventEnd`: Valid only when `isEventActive` is **true**. Integer indicating the number of minutes until the event ends.22. `timeUntilEventEndFormatted`: String displaying the `timeUntilEventEnd` formatted in English for users. If `isEventActive` is **false**, `timeUntilEventEndFormatted` will display **unavailable**.23. `shuffleAtEventStart`: Valid only when `isEventActive` is **true**. Boolean indicating if the users in the prequeue are shuffled randomly when the event starts.24. `turnstile`: Empty when turnstile isn&apos;t enabled. String displaying an html tag to display the Turnstile widget. Please add the `{{{turnstile}}}` tag to the `custom_html` template to ensure the Turnstile widget appears.25. `infiniteQueue`: Boolean indicating whether the response is for a user in the infinite queue.An example cURL to a waiting room could be:curl -X GET &quot;https://example.com/waitingroom&quot; \-H &quot;Accept: application/json&quot;If `json_response_enabled` is **true** and the request hits the waiting room, an example JSON response when `queueingMethod` is **fifo** and no event is active could be:{&quot;cfWaitingRoom&quot;: {&quot;inWaitingRoom&quot;: true,&quot;waitTimeKnown&quot;: true,&quot;waitTime&quot;: 10,&quot;waitTime25Percentile&quot;: 0,&quot;waitTime50Percentile&quot;: 0,&quot;waitTime75Percentile&quot;: 0,&quot;waitTimeFormatted&quot;: &quot;10 minutes&quot;,&quot;queueIsFull&quot;: false,&quot;queueAll&quot;: false,&quot;lastUpdated&quot;: &quot;2020-08-03T23:46:00.000Z&quot;,&quot;refreshIntervalSeconds&quot;: 20,&quot;queueingMethod&quot;: &quot;fifo&quot;,&quot;isFIFOQueue&quot;: true,&quot;isRandomQueue&quot;: false,&quot;isPassthroughQueue&quot;: false,&quot;isRejectQueue&quot;: false,&quot;isEventActive&quot;: false,&quot;isEventPrequeueing&quot;: false,&quot;timeUntilEventStart&quot;: 0,&quot;timeUntilEventStartFormatted&quot;: &quot;unavailable&quot;,&quot;timeUntilEventEnd&quot;: 0,&quot;timeUntilEventEndFormatted&quot;: &quot;unavailable&quot;,&quot;shuffleAtEventStart&quot;: false}}If `json_response_enabled` is **true** and the request hits the waiting room, an example JSON response when `queueingMethod` is **random** and an event is active could be:{&quot;cfWaitingRoom&quot;: {&quot;inWaitingRoom&quot;: true,&quot;waitTimeKnown&quot;: true,&quot;waitTime&quot;: 10,&quot;waitTime25Percentile&quot;: 5,&quot;waitTime50Percentile&quot;: 10,&quot;waitTime75Percentile&quot;: 15,&quot;waitTimeFormatted&quot;: &quot;5 minutes to 15 minutes&quot;,&quot;queueIsFull&quot;: false,&quot;queueAll&quot;: false,&quot;lastUpdated&quot;: &quot;2020-08-03T23:46:00.000Z&quot;,&quot;refreshIntervalSeconds&quot;: 20,&quot;queueingMethod&quot;: &quot;random&quot;,&quot;isFIFOQueue&quot;: false,&quot;isRandomQueue&quot;: true,&quot;isPassthroughQueue&quot;: false,&quot;isRejectQueue&quot;: false,&quot;isEventActive&quot;: true,&quot;isEventPrequeueing&quot;: false,&quot;timeUntilEventStart&quot;: 0,&quot;timeUntilEventStartFormatted&quot;: &quot;unavailable&quot;,&quot;timeUntilEventEnd&quot;: 15,&quot;timeUntilEventEndFormatted&quot;: &quot;15 minutes&quot;,&quot;shuffleAtEventStart&quot;: true}}
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class Waitingroom_json_response_enabled : IAdditionalDataHolder, IParsable
    {
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>Only available for the Waiting Room Advanced subscription. If `true`, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object with information on the user&apos;s status in the waiting room as opposed to the configured static HTML page. This JSON response object has one property `cfWaitingRoom` which is an object containing the following fields:1. `inWaitingRoom`: Boolean indicating if the user is in the waiting room (always **true**).2. `waitTimeKnown`: Boolean indicating if the current estimated wait times are accurate. If **false**, they are not available.3. `waitTime`: Valid only when `waitTimeKnown` is **true**. Integer indicating the current estimated time in minutes the user will wait in the waiting room. When `queueingMethod` is **random**, this is set to `waitTime50Percentile`.4. `waitTime25Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 25% of users that gain entry the fastest (25th percentile).5. `waitTime50Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 50% of users that gain entry the fastest (50th percentile). In other words, half of the queued users are expected to let into the origin website before `waitTime50Percentile` and half are expected to be let in after it.6. `waitTime75Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 75% of users that gain entry the fastest (75th percentile).7. `waitTimeFormatted`: String displaying the `waitTime` formatted in English for users. If `waitTimeKnown` is **false**, `waitTimeFormatted` will display **unavailable**.8. `queueIsFull`: Boolean indicating if the waiting room&apos;s queue is currently full and not accepting new users at the moment.9. `queueAll`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website.10. `lastUpdated`: String displaying the timestamp as an ISO 8601 string of the user&apos;s last attempt to leave the waiting room and be let into the origin website. The user is able to make another attempt after `refreshIntervalSeconds` past this time. If the user makes a request too soon, it will be ignored and `lastUpdated` will not change.11. `refreshIntervalSeconds`: Integer indicating the number of seconds after `lastUpdated` until the user is able to make another attempt to leave the waiting room and be let into the origin website. When the `queueingMethod` is `reject`, there is no specified refresh time â€”\_it will always be **zero**.12. `queueingMethod`: The queueing method currently used by the waiting room. It is either **fifo**, **random**, **passthrough**, or **reject**.13. `isFIFOQueue`: Boolean indicating if the waiting room uses a FIFO (First-In-First-Out) queue.14. `isRandomQueue`: Boolean indicating if the waiting room uses a Random queue where users gain access randomly.15. `isPassthroughQueue`: Boolean indicating if the waiting room uses a passthrough queue. Keep in mind that when passthrough is enabled, this JSON response will only exist when `queueAll` is **true** or `isEventPrequeueing` is **true** because in all other cases requests will go directly to the origin.16. `isRejectQueue`: Boolean indicating if the waiting room uses a reject queue.17. `isEventActive`: Boolean indicating if an event is currently occurring. Events are able to change a waiting room&apos;s behavior during a specified period of time. For additional information, look at the event properties `prequeue_start_time`, `event_start_time`, and `event_end_time` in the documentation for creating waiting room events. Events are considered active between these start and end times, as well as during the prequeueing period if it exists.18. `isEventPrequeueing`: Valid only when `isEventActive` is **true**. Boolean indicating if an event is currently prequeueing users before it starts.19. `timeUntilEventStart`: Valid only when `isEventPrequeueing` is **true**. Integer indicating the number of minutes until the event starts.20. `timeUntilEventStartFormatted`: String displaying the `timeUntilEventStart` formatted in English for users. If `isEventPrequeueing` is **false**, `timeUntilEventStartFormatted` will display **unavailable**.21. `timeUntilEventEnd`: Valid only when `isEventActive` is **true**. Integer indicating the number of minutes until the event ends.22. `timeUntilEventEndFormatted`: String displaying the `timeUntilEventEnd` formatted in English for users. If `isEventActive` is **false**, `timeUntilEventEndFormatted` will display **unavailable**.23. `shuffleAtEventStart`: Valid only when `isEventActive` is **true**. Boolean indicating if the users in the prequeue are shuffled randomly when the event starts.24. `turnstile`: Empty when turnstile isn&apos;t enabled. String displaying an html tag to display the Turnstile widget. Please add the `{{{turnstile}}}` tag to the `custom_html` template to ensure the Turnstile widget appears.25. `infiniteQueue`: Boolean indicating whether the response is for a user in the infinite queue.An example cURL to a waiting room could be:curl -X GET &quot;https://example.com/waitingroom&quot; \-H &quot;Accept: application/json&quot;If `json_response_enabled` is **true** and the request hits the waiting room, an example JSON response when `queueingMethod` is **fifo** and no event is active could be:{&quot;cfWaitingRoom&quot;: {&quot;inWaitingRoom&quot;: true,&quot;waitTimeKnown&quot;: true,&quot;waitTime&quot;: 10,&quot;waitTime25Percentile&quot;: 0,&quot;waitTime50Percentile&quot;: 0,&quot;waitTime75Percentile&quot;: 0,&quot;waitTimeFormatted&quot;: &quot;10 minutes&quot;,&quot;queueIsFull&quot;: false,&quot;queueAll&quot;: false,&quot;lastUpdated&quot;: &quot;2020-08-03T23:46:00.000Z&quot;,&quot;refreshIntervalSeconds&quot;: 20,&quot;queueingMethod&quot;: &quot;fifo&quot;,&quot;isFIFOQueue&quot;: true,&quot;isRandomQueue&quot;: false,&quot;isPassthroughQueue&quot;: false,&quot;isRejectQueue&quot;: false,&quot;isEventActive&quot;: false,&quot;isEventPrequeueing&quot;: false,&quot;timeUntilEventStart&quot;: 0,&quot;timeUntilEventStartFormatted&quot;: &quot;unavailable&quot;,&quot;timeUntilEventEnd&quot;: 0,&quot;timeUntilEventEndFormatted&quot;: &quot;unavailable&quot;,&quot;shuffleAtEventStart&quot;: false}}If `json_response_enabled` is **true** and the request hits the waiting room, an example JSON response when `queueingMethod` is **random** and an event is active could be:{&quot;cfWaitingRoom&quot;: {&quot;inWaitingRoom&quot;: true,&quot;waitTimeKnown&quot;: true,&quot;waitTime&quot;: 10,&quot;waitTime25Percentile&quot;: 5,&quot;waitTime50Percentile&quot;: 10,&quot;waitTime75Percentile&quot;: 15,&quot;waitTimeFormatted&quot;: &quot;5 minutes to 15 minutes&quot;,&quot;queueIsFull&quot;: false,&quot;queueAll&quot;: false,&quot;lastUpdated&quot;: &quot;2020-08-03T23:46:00.000Z&quot;,&quot;refreshIntervalSeconds&quot;: 20,&quot;queueingMethod&quot;: &quot;random&quot;,&quot;isFIFOQueue&quot;: false,&quot;isRandomQueue&quot;: true,&quot;isPassthroughQueue&quot;: false,&quot;isRejectQueue&quot;: false,&quot;isEventActive&quot;: true,&quot;isEventPrequeueing&quot;: false,&quot;timeUntilEventStart&quot;: 0,&quot;timeUntilEventStartFormatted&quot;: &quot;unavailable&quot;,&quot;timeUntilEventEnd&quot;: 15,&quot;timeUntilEventEndFormatted&quot;: &quot;15 minutes&quot;,&quot;shuffleAtEventStart&quot;: true}}</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Waitingroom_json_response_enabled? Value { get; set; }
#nullable restore
#else
        public global::Soenneker.Cloudflare.OpenApiClient.Models.Waitingroom_json_response_enabled Value { get; set; }
#endif
        /// <summary>
        /// Instantiates a new <see cref="global::Soenneker.Cloudflare.OpenApiClient.Models.Waitingroom_json_response_enabled"/> and sets the default values.
        /// </summary>
        public Waitingroom_json_response_enabled()
        {
            AdditionalData = new Dictionary<string, object>();
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Soenneker.Cloudflare.OpenApiClient.Models.Waitingroom_json_response_enabled"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::Soenneker.Cloudflare.OpenApiClient.Models.Waitingroom_json_response_enabled CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::Soenneker.Cloudflare.OpenApiClient.Models.Waitingroom_json_response_enabled();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "value", n => { Value = n.GetObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Waitingroom_json_response_enabled>(global::Soenneker.Cloudflare.OpenApiClient.Models.Waitingroom_json_response_enabled.CreateFromDiscriminatorValue); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            writer.WriteObjectValue<global::Soenneker.Cloudflare.OpenApiClient.Models.Waitingroom_json_response_enabled>("value", Value);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
#pragma warning restore CS0618
